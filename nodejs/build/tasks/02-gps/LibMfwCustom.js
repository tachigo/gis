'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _modules = _interopRequireDefault(require("./../../modules"));

var _terraformerWktParser = _interopRequireDefault(require("terraformer-wkt-parser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LibMfwCustom {
  static async countryIntersectWith(pg, id) {
    const table = 'gps.mfw';
    const sql = `with 
    ta as (
      select geom from ${table} where id = $1::bigint
    )
    select tb.id as id, tb.zh_name as zh_name, tb.iso as iso from ${table} as tb, ta 
    where tb.id > 900000 and level::integer <= 1 and tb.id != $1::bigint and st_intersects(ta.geom, tb.geom) = true order by id asc`;
    const res = await pg.query(sql, [id]);
    const items = [];

    for await (const row of res.rows) {
      items.push({
        id: +row['id'],
        zhName: row['zh_name']
      });
    }

    return items;
  }

  static async removeInteriorRing(pg, id) {
    const table = 'gps.mfw';
    const sql = `with 
    ta as (
      select (st_dump(geom)).geom as geom from ${table} where id = $1
    )
    , tb as (
      select st_exteriorring(geom) as geom from ta
    )
    , tc as (
      select st_polygonize(geom) as geom from tb
    )
    insert into ${table} (id, geom) 
    select $1::bigint as id, st_multi(geom) as geom from tc 
    on conflict (id) do update set geom = excluded.geom`;
    await pg.query(sql, [id]);
  }

  static async importChinaMaritime(pg) {
    const table = 'gps.mfw';
    const shpFilename = `${_modules.default.Utils.dataDir}/shapefile/china-maritime/china.shp`;
    const dbfFilename = `${_modules.default.Utils.dataDir}/shapefile/china-maritime/china.dbf`;
    const id = 1;

    const lineResolve = async result => {
      const geometry = _terraformerWktParser.default.convert(result.value.geometry);

      const startTime = new Date().getTime(); // 计时

      const sql = `insert into ${table} (id, geom) 
      values ($1::bigint, ST_Multi(ST_GeomFromText($2, 4326))::geometry) 
      on conflict (id) do update 
      set geom = excluded.geom`;
      const params = [id, geometry];
      await pg.query(sql, params).catch(e => {
        console.log(sql);
        throw e;
      });
      const endTime = new Date().getTime();
      const costTime = endTime - startTime;
      console.log(`${table}#${id} cost ... ${costTime / 1000} s`);
    };

    await _modules.default.ShapeFile.readLine(shpFilename, dbfFilename, lineResolve);
    await this.removeInteriorRing(pg, id);
    await _modules.default.PgSQL.getPostGis().validatePolygon(pg, id, table, 'id', 'geom');
  }

  static async geomADiffB2A(pg, aId, bId) {
    const table = 'gps.mfw';
    const sql = `with
    ta as (select 1 as id, geom from ${table} where id = ${aId}) -- A
    , tb as (select 1 as id, geom from ${table} where id = ${bId}) -- B
    , fixed as (
       select ${aId} as id, st_difference(st_makevalid(ta.geom), st_makevalid(tb.geom)) as geom
       from ta left join tb
       on ta.id = tb.id
    )
    insert into ${table} (id, geom)
    select id, geom 
    from fixed
    on conflict (id) do update set 
    geom = excluded.geom;`;
    await pg.query(sql);
  }

  static async fixCountryIntersectsWithChina(pg) {
    const bId = 1;
    const countryIntersectWithChina = await this.countryIntersectWith(pg, bId);
    console.log(countryIntersectWithChina);

    for await (const item of countryIntersectWithChina) {
      const aId = item.id;
      await _modules.default.Utils.call(`${item.zhName}#${aId}`, this.geomADiffB2A.bind(this), [pg, aId, bId]);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, aId, 'gps.mfw', 'id', 'geom');
    }
  }

  static async fixOthers01(pg) {
    // 乌克兰和俄罗斯的克里米亚半岛归俄罗斯 乌克兰 - 俄罗斯 => 乌克兰
    const that = this;
    await _modules.default.Utils.call(`乌克兰#900177 - 俄罗斯#900136 => 乌克兰#900177`, async () => {
      await that.geomADiffB2A(pg, 900177, 900136);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900177, 'gps.mfw', 'id', 'geom');
    });
  }

  static async fixOthers02(pg) {
    // 苏丹和南苏丹的交集归苏丹 南苏丹 - 苏丹 => 南苏丹
    const that = this;
    await _modules.default.Utils.call(`南苏丹#900156 - 苏丹#900159 => 南苏丹#900156`, async () => {
      await that.geomADiffB2A(pg, 900156, 900159);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900156, 'gps.mfw', 'id', 'geom');
    });
  }

  static async fixOthers03(pg) {
    // 摩洛哥和西撒哈拉的交集归西撒哈拉 摩洛哥 - 西撒哈拉 => 摩洛哥
    const that = this;
    await _modules.default.Utils.call(`摩洛哥#900112 - 西撒哈拉#900185 => 摩洛哥#900112`, async () => {
      await that.geomADiffB2A(pg, 900112, 900185);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900112, 'gps.mfw', 'id', 'geom');
    });
  }

  static async fixOthers04(pg) {
    // 摩洛哥和西班牙
    const that = this;
    await _modules.default.Utils.call(`摩洛哥#900112 - 西班牙#900157 => 摩洛哥#900112`, async () => {
      await that.geomADiffB2A(pg, 900112, 900157);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900112, 'gps.mfw', 'id', 'geom');
    });
  }

  static async fixOthers05(pg) {
    // 将南苏丹取凸包后与周围国家取差集
    const id = 900156; // 南苏丹

    const table = 'gps.mfw';
    await pg.query(`update ${table} set geom = st_convexhull(geom) where id = $1::bigint`, [id]);
    const countryIntersectWith = await this.countryIntersectWith(pg, id);
    console.log(countryIntersectWith);

    for await (const item of countryIntersectWith) {
      const bId = item.id;
      await _modules.default.Utils.call(`${item.zhName}#${bId}`, this.geomADiffB2A.bind(this), [pg, id, bId]);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, id, 'gps.mfw', 'id', 'geom');
    }
  }

  static async fixOthers06(pg) {
    // 克罗地亚#900040 塞尔维亚#900146
    // 塞尔维亚#900146 - 克罗地亚#900040 => 塞尔维亚#900146
    const that = this;
    await _modules.default.Utils.call(`塞尔维亚#900146 - 克罗地亚#900040 => 塞尔维亚#900146`, async () => {
      await that.geomADiffB2A(pg, 900146, 900040);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900146, 'gps.mfw', 'id', 'geom');
    }); // 将塞尔维亚取凸包后与周围国家取差集

    const id = 900146; // 塞尔维亚

    const table = 'gps.mfw';
    await pg.query(`update ${table} set geom = st_convexhull(geom) where id = $1::bigint`, [id]);
    const countryIntersectWith = await this.countryIntersectWith(pg, id);
    console.log(countryIntersectWith);

    for await (const item of countryIntersectWith) {
      const bId = item.id;
      await _modules.default.Utils.call(`${item.zhName}#${bId}`, this.geomADiffB2A.bind(this), [pg, id, bId]);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, id, 'gps.mfw', 'id', 'geom');
    }
  }

  static async fixOthers07(pg) {
    // 卢森堡#900096 德国#900059
    const that = this;
    await _modules.default.Utils.call(`卢森堡#900096 - 德国#900059 => 卢森堡#900096`, async () => {
      await that.geomADiffB2A(pg, 900096, 900059);
      await _modules.default.PgSQL.getPostGis().validatePolygon(pg, 900096, 'gps.mfw', 'id', 'geom');
    });
  }

}

var _default = LibMfwCustom;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YXNrcy8wMi1ncHMvTGliTWZ3Q3VzdG9tLmpzIl0sIm5hbWVzIjpbIkxpYk1md0N1c3RvbSIsImNvdW50cnlJbnRlcnNlY3RXaXRoIiwicGciLCJpZCIsInRhYmxlIiwic3FsIiwicmVzIiwicXVlcnkiLCJpdGVtcyIsInJvdyIsInJvd3MiLCJwdXNoIiwiemhOYW1lIiwicmVtb3ZlSW50ZXJpb3JSaW5nIiwiaW1wb3J0Q2hpbmFNYXJpdGltZSIsInNocEZpbGVuYW1lIiwiJCIsIlV0aWxzIiwiZGF0YURpciIsImRiZkZpbGVuYW1lIiwibGluZVJlc29sdmUiLCJyZXN1bHQiLCJnZW9tZXRyeSIsIldLVCIsImNvbnZlcnQiLCJ2YWx1ZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJnZXRUaW1lIiwicGFyYW1zIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImxvZyIsImVuZFRpbWUiLCJjb3N0VGltZSIsIlNoYXBlRmlsZSIsInJlYWRMaW5lIiwiUGdTUUwiLCJnZXRQb3N0R2lzIiwidmFsaWRhdGVQb2x5Z29uIiwiZ2VvbUFEaWZmQjJBIiwiYUlkIiwiYklkIiwiZml4Q291bnRyeUludGVyc2VjdHNXaXRoQ2hpbmEiLCJjb3VudHJ5SW50ZXJzZWN0V2l0aENoaW5hIiwiaXRlbSIsImNhbGwiLCJiaW5kIiwiZml4T3RoZXJzMDEiLCJ0aGF0IiwiZml4T3RoZXJzMDIiLCJmaXhPdGhlcnMwMyIsImZpeE90aGVyczA0IiwiZml4T3RoZXJzMDUiLCJmaXhPdGhlcnMwNiIsImZpeE90aGVyczA3Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQUVBOztBQUNBOzs7O0FBRUEsTUFBTUEsWUFBTixDQUFtQjtBQUVqQixlQUFhQyxvQkFBYixDQUFrQ0MsRUFBbEMsRUFBc0NDLEVBQXRDLEVBQTBDO0FBQ3hDLFVBQU1DLEtBQUssR0FBRyxTQUFkO0FBQ0EsVUFBTUMsR0FBRyxHQUFJOzt5QkFFUUQsS0FBTTs7b0VBRXFDQSxLQUFNO29JQUp0RTtBQU1B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Q0MsRUFBekMsRUFBNkMsU0FBN0MsRUFBd0QsSUFBeEQsRUFBOEQsTUFBOUQsQ0FBTjtBQUNEO0FBQ0Y7O0FBR0QsZUFBYXFELFdBQWIsQ0FBeUJ0RCxFQUF6QixFQUE2QjtBQUMzQjtBQUNBLFVBQU1nRCxJQUFJLEdBQUcsSUFBYjtBQUNBLFVBQU1sQyxpQkFBRUMsS0FBRixDQUFROEIsSUFBUixDQUFjLHNDQUFkLEVBQXFELFlBQVk7QUFDckUsWUFBTUcsSUFBSSxDQUFDVCxZQUFMLENBQWtCdkMsRUFBbEIsRUFBc0IsTUFBdEIsRUFBOEIsTUFBOUIsQ0FBTjtBQUNBLFlBQU1jLGlCQUFFc0IsS0FBRixDQUFRQyxVQUFSLEdBQXFCQyxlQUFyQixDQUFxQ3RDLEVBQXJDLEVBQXlDLE1BQXpDLEVBQWlELFNBQWpELEVBQTRELElBQTVELEVBQWtFLE1BQWxFLENBQU47QUFDRCxLQUhLLENBQU47QUFJRDs7QUExTGdCOztlQThMSkYsWSIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICQgZnJvbSAnLi8uLi8uLi9tb2R1bGVzJztcbmltcG9ydCBXS1QgZnJvbSBcInRlcnJhZm9ybWVyLXdrdC1wYXJzZXJcIjtcblxuY2xhc3MgTGliTWZ3Q3VzdG9tIHtcblxuICBzdGF0aWMgYXN5bmMgY291bnRyeUludGVyc2VjdFdpdGgocGcsIGlkKSB7XG4gICAgY29uc3QgdGFibGUgPSAnZ3BzLm1mdyc7XG4gICAgY29uc3Qgc3FsID0gYHdpdGggXG4gICAgdGEgYXMgKFxuICAgICAgc2VsZWN0IGdlb20gZnJvbSAke3RhYmxlfSB3aGVyZSBpZCA9ICQxOjpiaWdpbnRcbiAgICApXG4gICAgc2VsZWN0IHRiLmlkIGFzIGlkLCB0Yi56aF9uYW1lIGFzIHpoX25hbWUsIHRiLmlzbyBhcyBpc28gZnJvbSAke3RhYmxlfSBhcyB0YiwgdGEgXG4gICAgd2hlcmUgdGIuaWQgPiA5MDAwMDAgYW5kIGxldmVsOjppbnRlZ2VyIDw9IDEgYW5kIHRiLmlkICE9ICQxOjpiaWdpbnQgYW5kIHN0X2ludGVyc2VjdHModGEuZ2VvbSwgdGIuZ2VvbSkgPSB0cnVlIG9yZGVyIGJ5IGlkIGFzY2A7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcGcucXVlcnkoc3FsLCBbaWRdKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3Qgcm93IG9mIHJlcy5yb3dzKSB7XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgaWQ6ICtyb3dbJ2lkJ10sXG4gICAgICAgIHpoTmFtZTogcm93Wyd6aF9uYW1lJ10sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cblxuXG5cbiAgc3RhdGljIGFzeW5jIHJlbW92ZUludGVyaW9yUmluZyhwZywgaWQpIHtcbiAgICBjb25zdCB0YWJsZSA9ICdncHMubWZ3JztcbiAgICBjb25zdCBzcWwgPSBgd2l0aCBcbiAgICB0YSBhcyAoXG4gICAgICBzZWxlY3QgKHN0X2R1bXAoZ2VvbSkpLmdlb20gYXMgZ2VvbSBmcm9tICR7dGFibGV9IHdoZXJlIGlkID0gJDFcbiAgICApXG4gICAgLCB0YiBhcyAoXG4gICAgICBzZWxlY3Qgc3RfZXh0ZXJpb3JyaW5nKGdlb20pIGFzIGdlb20gZnJvbSB0YVxuICAgIClcbiAgICAsIHRjIGFzIChcbiAgICAgIHNlbGVjdCBzdF9wb2x5Z29uaXplKGdlb20pIGFzIGdlb20gZnJvbSB0YlxuICAgIClcbiAgICBpbnNlcnQgaW50byAke3RhYmxlfSAoaWQsIGdlb20pIFxuICAgIHNlbGVjdCAkMTo6YmlnaW50IGFzIGlkLCBzdF9tdWx0aShnZW9tKSBhcyBnZW9tIGZyb20gdGMgXG4gICAgb24gY29uZmxpY3QgKGlkKSBkbyB1cGRhdGUgc2V0IGdlb20gPSBleGNsdWRlZC5nZW9tYDtcbiAgICBhd2FpdCBwZy5xdWVyeShzcWwsIFtpZF0pO1xuICB9XG5cblxuXG4gIHN0YXRpYyBhc3luYyBpbXBvcnRDaGluYU1hcml0aW1lKHBnKSB7XG4gICAgY29uc3QgdGFibGUgPSAnZ3BzLm1mdyc7XG4gICAgY29uc3Qgc2hwRmlsZW5hbWUgPSBgJHskLlV0aWxzLmRhdGFEaXJ9L3NoYXBlZmlsZS9jaGluYS1tYXJpdGltZS9jaGluYS5zaHBgO1xuICAgIGNvbnN0IGRiZkZpbGVuYW1lID0gYCR7JC5VdGlscy5kYXRhRGlyfS9zaGFwZWZpbGUvY2hpbmEtbWFyaXRpbWUvY2hpbmEuZGJmYDtcbiAgICBjb25zdCBpZCA9IDE7XG4gICAgY29uc3QgbGluZVJlc29sdmUgPSBhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IFdLVC5jb252ZXJ0KHJlc3VsdC52YWx1ZS5nZW9tZXRyeSk7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyAvLyDorqHml7ZcbiAgICAgIGNvbnN0IHNxbCA9IGBpbnNlcnQgaW50byAke3RhYmxlfSAoaWQsIGdlb20pIFxuICAgICAgdmFsdWVzICgkMTo6YmlnaW50LCBTVF9NdWx0aShTVF9HZW9tRnJvbVRleHQoJDIsIDQzMjYpKTo6Z2VvbWV0cnkpIFxuICAgICAgb24gY29uZmxpY3QgKGlkKSBkbyB1cGRhdGUgXG4gICAgICBzZXQgZ2VvbSA9IGV4Y2x1ZGVkLmdlb21gO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2lkLCBnZW9tZXRyeV07XG4gICAgICBhd2FpdCBwZy5xdWVyeShzcWwsIHBhcmFtcylcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKHNxbCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSlcbiAgICAgIDtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgY29zdFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYCR7dGFibGV9IyR7aWR9IGNvc3QgLi4uICR7Y29zdFRpbWUgLyAxMDAwfSBzYCk7XG4gICAgfTtcbiAgICBhd2FpdCAkLlNoYXBlRmlsZS5yZWFkTGluZShzaHBGaWxlbmFtZSwgZGJmRmlsZW5hbWUsIGxpbmVSZXNvbHZlKTtcbiAgICBhd2FpdCB0aGlzLnJlbW92ZUludGVyaW9yUmluZyhwZywgaWQpO1xuICAgIGF3YWl0ICQuUGdTUUwuZ2V0UG9zdEdpcygpLnZhbGlkYXRlUG9seWdvbihwZywgaWQsIHRhYmxlLCAnaWQnLCAnZ2VvbScpO1xuICB9XG5cblxuICBzdGF0aWMgYXN5bmMgZ2VvbUFEaWZmQjJBKHBnLCBhSWQsIGJJZCkge1xuICAgIGNvbnN0IHRhYmxlID0gJ2dwcy5tZncnO1xuICAgIGNvbnN0IHNxbCA9IGB3aXRoXG4gICAgdGEgYXMgKHNlbGVjdCAxIGFzIGlkLCBnZW9tIGZyb20gJHt0YWJsZX0gd2hlcmUgaWQgPSAke2FJZH0pIC0tIEFcbiAgICAsIHRiIGFzIChzZWxlY3QgMSBhcyBpZCwgZ2VvbSBmcm9tICR7dGFibGV9IHdoZXJlIGlkID0gJHtiSWR9KSAtLSBCXG4gICAgLCBmaXhlZCBhcyAoXG4gICAgICAgc2VsZWN0ICR7YUlkfSBhcyBpZCwgc3RfZGlmZmVyZW5jZShzdF9tYWtldmFsaWQodGEuZ2VvbSksIHN0X21ha2V2YWxpZCh0Yi5nZW9tKSkgYXMgZ2VvbVxuICAgICAgIGZyb20gdGEgbGVmdCBqb2luIHRiXG4gICAgICAgb24gdGEuaWQgPSB0Yi5pZFxuICAgIClcbiAgICBpbnNlcnQgaW50byAke3RhYmxlfSAoaWQsIGdlb20pXG4gICAgc2VsZWN0IGlkLCBnZW9tIFxuICAgIGZyb20gZml4ZWRcbiAgICBvbiBjb25mbGljdCAoaWQpIGRvIHVwZGF0ZSBzZXQgXG4gICAgZ2VvbSA9IGV4Y2x1ZGVkLmdlb207YDtcbiAgICBhd2FpdCBwZy5xdWVyeShzcWwpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZpeENvdW50cnlJbnRlcnNlY3RzV2l0aENoaW5hKHBnKSB7XG4gICAgY29uc3QgYklkID0gMTtcbiAgICBjb25zdCBjb3VudHJ5SW50ZXJzZWN0V2l0aENoaW5hID0gYXdhaXQgdGhpcy5jb3VudHJ5SW50ZXJzZWN0V2l0aChwZywgYklkKTtcbiAgICBjb25zb2xlLmxvZyhjb3VudHJ5SW50ZXJzZWN0V2l0aENoaW5hKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY291bnRyeUludGVyc2VjdFdpdGhDaGluYSkge1xuICAgICAgY29uc3QgYUlkID0gaXRlbS5pZDtcbiAgICAgIGF3YWl0ICQuVXRpbHMuY2FsbChgJHtpdGVtLnpoTmFtZX0jJHthSWR9YCwgdGhpcy5nZW9tQURpZmZCMkEuYmluZCh0aGlzKSwgW3BnLCBhSWQsIGJJZF0pO1xuICAgICAgYXdhaXQgJC5QZ1NRTC5nZXRQb3N0R2lzKCkudmFsaWRhdGVQb2x5Z29uKHBnLCBhSWQsICdncHMubWZ3JywgJ2lkJywgJ2dlb20nKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgc3RhdGljIGFzeW5jIGZpeE90aGVyczAxKHBnKSB7XG4gICAgLy8g5LmM5YWL5YWw5ZKM5L+E572X5pav55qE5YWL6YeM57Gz5Lqa5Y2K5bKb5b2S5L+E572X5pavIOS5jOWFi+WFsCAtIOS/hOe9l+aWryA9PiDkuYzlhYvlhbBcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBhd2FpdCAkLlV0aWxzLmNhbGwoYOS5jOWFi+WFsCM5MDAxNzcgLSDkv4TnvZfmlq8jOTAwMTM2ID0+IOS5jOWFi+WFsCM5MDAxNzdgLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGF0Lmdlb21BRGlmZkIyQShwZywgOTAwMTc3LCA5MDAxMzYpO1xuICAgICAgYXdhaXQgJC5QZ1NRTC5nZXRQb3N0R2lzKCkudmFsaWRhdGVQb2x5Z29uKHBnLCA5MDAxNzcsICdncHMubWZ3JywgJ2lkJywgJ2dlb20nKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmaXhPdGhlcnMwMihwZykge1xuICAgIC8vIOiLj+S4ueWSjOWNl+iLj+S4ueeahOS6pOmbhuW9kuiLj+S4uSDljZfoi4/kuLkgLSDoi4/kuLkgPT4g5Y2X6IuP5Li5XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgYXdhaXQgJC5VdGlscy5jYWxsKGDljZfoi4/kuLkjOTAwMTU2IC0g6IuP5Li5IzkwMDE1OSA9PiDljZfoi4/kuLkjOTAwMTU2YCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhhdC5nZW9tQURpZmZCMkEocGcsIDkwMDE1NiwgOTAwMTU5KTtcbiAgICAgIGF3YWl0ICQuUGdTUUwuZ2V0UG9zdEdpcygpLnZhbGlkYXRlUG9seWdvbihwZywgOTAwMTU2LCAnZ3BzLm1mdycsICdpZCcsICdnZW9tJyk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZml4T3RoZXJzMDMocGcpIHtcbiAgICAvLyDmkanmtJvlk6Xlkozopb/mkpLlk4jmi4nnmoTkuqTpm4blvZLopb/mkpLlk4jmi4kg5pGp5rSb5ZOlIC0g6KW/5pKS5ZOI5ouJID0+IOaRqea0m+WTpVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIGF3YWl0ICQuVXRpbHMuY2FsbChg5pGp5rSb5ZOlIzkwMDExMiAtIOilv+aSkuWTiOaLiSM5MDAxODUgPT4g5pGp5rSb5ZOlIzkwMDExMmAsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoYXQuZ2VvbUFEaWZmQjJBKHBnLCA5MDAxMTIsIDkwMDE4NSk7XG4gICAgICBhd2FpdCAkLlBnU1FMLmdldFBvc3RHaXMoKS52YWxpZGF0ZVBvbHlnb24ocGcsIDkwMDExMiwgJ2dwcy5tZncnLCAnaWQnLCAnZ2VvbScpO1xuICAgIH0pO1xuICB9XG5cblxuICBzdGF0aWMgYXN5bmMgZml4T3RoZXJzMDQocGcpIHtcbiAgICAvLyDmkanmtJvlk6Xlkozopb/nj63niZlcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBhd2FpdCAkLlV0aWxzLmNhbGwoYOaRqea0m+WTpSM5MDAxMTIgLSDopb/nj63niZkjOTAwMTU3ID0+IOaRqea0m+WTpSM5MDAxMTJgLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGF0Lmdlb21BRGlmZkIyQShwZywgOTAwMTEyLCA5MDAxNTcpO1xuICAgICAgYXdhaXQgJC5QZ1NRTC5nZXRQb3N0R2lzKCkudmFsaWRhdGVQb2x5Z29uKHBnLCA5MDAxMTIsICdncHMubWZ3JywgJ2lkJywgJ2dlb20nKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgc3RhdGljIGFzeW5jIGZpeE90aGVyczA1KHBnKSB7XG4gICAgLy8g5bCG5Y2X6IuP5Li55Y+W5Ye45YyF5ZCO5LiO5ZGo5Zu05Zu95a625Y+W5beu6ZuGXG4gICAgY29uc3QgaWQgPSA5MDAxNTY7IC8vIOWNl+iLj+S4uVxuICAgIGNvbnN0IHRhYmxlID0gJ2dwcy5tZncnO1xuICAgIGF3YWl0IHBnLnF1ZXJ5KGB1cGRhdGUgJHt0YWJsZX0gc2V0IGdlb20gPSBzdF9jb252ZXhodWxsKGdlb20pIHdoZXJlIGlkID0gJDE6OmJpZ2ludGAsIFtpZF0pO1xuICAgIGNvbnN0IGNvdW50cnlJbnRlcnNlY3RXaXRoID0gYXdhaXQgdGhpcy5jb3VudHJ5SW50ZXJzZWN0V2l0aChwZywgaWQpO1xuICAgIGNvbnNvbGUubG9nKGNvdW50cnlJbnRlcnNlY3RXaXRoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY291bnRyeUludGVyc2VjdFdpdGgpIHtcbiAgICAgIGNvbnN0IGJJZCA9IGl0ZW0uaWQ7XG4gICAgICBhd2FpdCAkLlV0aWxzLmNhbGwoYCR7aXRlbS56aE5hbWV9IyR7YklkfWAsIHRoaXMuZ2VvbUFEaWZmQjJBLmJpbmQodGhpcyksIFtwZywgaWQsIGJJZF0pO1xuICAgICAgYXdhaXQgJC5QZ1NRTC5nZXRQb3N0R2lzKCkudmFsaWRhdGVQb2x5Z29uKHBnLCBpZCwgJ2dwcy5tZncnLCAnaWQnLCAnZ2VvbScpO1xuICAgIH1cbiAgfVxuXG5cbiAgc3RhdGljIGFzeW5jIGZpeE90aGVyczA2KHBnKSB7XG4gICAgLy8g5YWL572X5Zyw5LqaIzkwMDA0MCDloZ7lsJTnu7TkupojOTAwMTQ2XG4gICAgLy8g5aGe5bCU57u05LqaIzkwMDE0NiAtIOWFi+e9l+WcsOS6miM5MDAwNDAgPT4g5aGe5bCU57u05LqaIzkwMDE0NlxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIGF3YWl0ICQuVXRpbHMuY2FsbChg5aGe5bCU57u05LqaIzkwMDE0NiAtIOWFi+e9l+WcsOS6miM5MDAwNDAgPT4g5aGe5bCU57u05LqaIzkwMDE0NmAsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoYXQuZ2VvbUFEaWZmQjJBKHBnLCA5MDAxNDYsIDkwMDA0MCk7XG4gICAgICBhd2FpdCAkLlBnU1FMLmdldFBvc3RHaXMoKS52YWxpZGF0ZVBvbHlnb24ocGcsIDkwMDE0NiwgJ2dwcy5tZncnLCAnaWQnLCAnZ2VvbScpO1xuICAgIH0pO1xuICAgIC8vIOWwhuWhnuWwlOe7tOS6muWPluWHuOWMheWQjuS4juWRqOWbtOWbveWutuWPluW3rumbhlxuICAgIGNvbnN0IGlkID0gOTAwMTQ2OyAvLyDloZ7lsJTnu7TkuppcbiAgICBjb25zdCB0YWJsZSA9ICdncHMubWZ3JztcbiAgICBhd2FpdCBwZy5xdWVyeShgdXBkYXRlICR7dGFibGV9IHNldCBnZW9tID0gc3RfY29udmV4aHVsbChnZW9tKSB3aGVyZSBpZCA9ICQxOjpiaWdpbnRgLCBbaWRdKTtcbiAgICBjb25zdCBjb3VudHJ5SW50ZXJzZWN0V2l0aCA9IGF3YWl0IHRoaXMuY291bnRyeUludGVyc2VjdFdpdGgocGcsIGlkKTtcbiAgICBjb25zb2xlLmxvZyhjb3VudHJ5SW50ZXJzZWN0V2l0aCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNvdW50cnlJbnRlcnNlY3RXaXRoKSB7XG4gICAgICBjb25zdCBiSWQgPSBpdGVtLmlkO1xuICAgICAgYXdhaXQgJC5VdGlscy5jYWxsKGAke2l0ZW0uemhOYW1lfSMke2JJZH1gLCB0aGlzLmdlb21BRGlmZkIyQS5iaW5kKHRoaXMpLCBbcGcsIGlkLCBiSWRdKTtcbiAgICAgIGF3YWl0ICQuUGdTUUwuZ2V0UG9zdEdpcygpLnZhbGlkYXRlUG9seWdvbihwZywgaWQsICdncHMubWZ3JywgJ2lkJywgJ2dlb20nKTtcbiAgICB9XG4gIH1cblxuXG4gIHN0YXRpYyBhc3luYyBmaXhPdGhlcnMwNyhwZykge1xuICAgIC8vIOWNouajruWgoSM5MDAwOTYg5b635Zu9IzkwMDA1OVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIGF3YWl0ICQuVXRpbHMuY2FsbChg5Y2i5qOu5aChIzkwMDA5NiAtIOW+t+WbvSM5MDAwNTkgPT4g5Y2i5qOu5aChIzkwMDA5NmAsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoYXQuZ2VvbUFEaWZmQjJBKHBnLCA5MDAwOTYsIDkwMDA1OSk7XG4gICAgICBhd2FpdCAkLlBnU1FMLmdldFBvc3RHaXMoKS52YWxpZGF0ZVBvbHlnb24ocGcsIDkwMDA5NiwgJ2dwcy5tZncnLCAnaWQnLCAnZ2VvbScpO1xuICAgIH0pO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTGliTWZ3Q3VzdG9tOyJdfQ==